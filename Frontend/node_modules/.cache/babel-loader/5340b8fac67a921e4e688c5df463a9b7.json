{"ast":null,"code":"var fs = require('fs');\n\nvar childprocess = require('child_process');\n\nvar path = require('path');\n\nvar assert = require('assert');\n\ntry {\n  var phantomjs = require('phantomjs-prebuilt');\n} catch (err) {\n  console.log('html-pdf: Failed to load PhantomJS module.', err);\n}\n/*\n* phantomjs version 1.8.1 and later should work.\n*\n* Create a PDF file out of an html string.\n*\n* Regions for the PDF page are:\n*\n* - Page Header  -> document.getElementById('pageHeader')\n* - Page Content -> document.getElementById('pageContent')\n* - Page Footer  -> document.getElementById('pageFooter')\n*\n* When no #pageContent is available, phantomjs will use document.body as pdf content\n*/\n\n\nmodule.exports = PDF;\n\nfunction PDF(html, options) {\n  this.html = html;\n  this.options = options || {};\n\n  if (this.options.script) {\n    this.script = path.normalize(this.options.script);\n  } else {\n    this.script = path.join(__dirname, 'scripts', 'pdf_a4_portrait.js');\n  }\n\n  if (this.options.filename) this.options.filename = path.resolve(this.options.filename);\n  if (!this.options.phantomPath) this.options.phantomPath = phantomjs && phantomjs.path;\n  this.options.phantomArgs = this.options.phantomArgs || [];\n  assert(this.options.phantomPath, \"html-pdf: Failed to load PhantomJS module. You have to set the path to the PhantomJS binary using 'options.phantomPath'\");\n  assert(typeof this.html === 'string' && this.html.length, \"html-pdf: Can't create a pdf without an html string\");\n  this.options.timeout = parseInt(this.options.timeout, 10) || 30000;\n}\n\nPDF.prototype.toBuffer = function PdfToBuffer(callback) {\n  this.exec(function execPdfToBuffer(err, res) {\n    if (err) return callback(err);\n    fs.readFile(res.filename, function readCallback(err, buffer) {\n      if (err) return callback(err);\n      fs.unlink(res.filename, function unlinkPdfFile(err) {\n        if (err) return callback(err);\n        callback(null, buffer);\n      });\n    });\n  });\n};\n\nPDF.prototype.toStream = function PdfToStream(callback) {\n  this.exec(function (err, res) {\n    if (err) return callback(err);\n\n    try {\n      var stream = fs.createReadStream(res.filename);\n    } catch (err) {\n      return callback(err);\n    }\n\n    stream.on('end', function () {\n      fs.unlink(res.filename, function unlinkPdfFile(err) {\n        if (err) console.log('html-pdf:', err);\n      });\n    });\n    callback(null, stream);\n  });\n};\n\nPDF.prototype.toFile = function PdfToFile(filename, callback) {\n  assert(arguments.length > 0, 'html-pdf: The method .toFile([filename, ]callback) requires a callback.');\n\n  if (filename instanceof Function) {\n    callback = filename;\n    filename = undefined;\n  } else {\n    this.options.filename = path.resolve(filename);\n  }\n\n  this.exec(callback);\n};\n\nPDF.prototype.exec = function PdfExec(callback) {\n  var child = childprocess.spawn(this.options.phantomPath, [].concat(this.options.phantomArgs, [this.script]), this.options.childProcessOptions);\n  var stderr = [];\n  var timeout = setTimeout(function execTimeout() {\n    respond(null, new Error('html-pdf: PDF generation timeout. Phantom.js script did not exit.'));\n  }, this.options.timeout);\n\n  function onError(buffer) {\n    stderr.push(buffer);\n  }\n\n  function onData(buffer) {\n    var result;\n\n    try {\n      var json = buffer.toString().trim();\n      if (json) result = JSON.parse(json);\n    } catch (err) {\n      // Proxy for debugging purposes\n      process.stdout.write(buffer);\n    }\n\n    if (result) respond(null, null, result);\n  }\n\n  var callbacked = false;\n\n  function respond(code, err, data) {\n    if (callbacked) return;\n    callbacked = true;\n    clearTimeout(timeout); // If we don't have an exit code, we kill the process, ignore stderr after this point\n\n    if (code === null) kill(child, onData, onError);\n\n    if (!data) {\n      if (!err && code) err = new Error(\"html-pdf: Received the exit code '\" + code + \"'\");else if (!err) err = new Error('html-pdf: Unknown Error');\n      var postfix = stderr.length ? '\\n' + Buffer.concat(stderr).toString() : '';\n      if (postfix) err.message += postfix;\n      return callback(err, null);\n    }\n\n    callback(null, data);\n  }\n\n  child.stdout.on('data', onData);\n  child.stderr.on('data', onError);\n  child.on('error', function onError(err) {\n    respond(null, err);\n  }); // An exit event is most likely an error because we didn't get any data at this point\n\n  child.on('close', respond);\n  child.on('exit', respond);\n  var config = JSON.stringify({\n    html: this.html,\n    options: this.options\n  });\n  child.stdin.write(config + '\\n', 'utf8');\n  child.stdin.end();\n};\n\nfunction kill(child, onData, onError) {\n  child.stdin.end();\n  child.kill();\n}","map":null,"metadata":{},"sourceType":"script"}